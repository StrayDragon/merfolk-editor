# FR-99: æµ‹è¯•ç”¨ä¾‹è§„åˆ’

> åŸºäº [Mermaid Flowchart å®˜æ–¹æ–‡æ¡£](https://mermaid.js.org/syntax/flowchart.html) æ„å»ºçš„å®Œæ•´æµ‹è¯•è¦†ç›–

## ğŸ“‹ æµ‹è¯•ç­–ç•¥

### æµ‹è¯•å±‚æ¬¡

1. **å•å…ƒæµ‹è¯•** - Parser/Serializer æ ¸å¿ƒé€»è¾‘
2. **é›†æˆæµ‹è¯•** - Parse â†’ Model â†’ Serialize å¾€è¿”ä¸€è‡´æ€§
3. **E2E æµ‹è¯•** - ç”¨æˆ·äº¤äº’åœºæ™¯

### æµ‹è¯•æ–‡ä»¶ç»“æ„

```
src/core/parser/MermaidParser.test.ts      # è§£æå™¨æµ‹è¯•
src/core/serializer/MermaidSerializer.test.ts  # åºåˆ—åŒ–å™¨æµ‹è¯•
src/core/parser/MermaidParser.compat.test.ts   # å…¼å®¹æ€§æµ‹è¯• (æ–°å¢)
e2e/flowchart.spec.ts                      # E2E æµ‹è¯•
```

---

## ğŸ§ª å…¼å®¹æ€§æµ‹è¯•ç”¨ä¾‹ (æ–°å¢æ–‡ä»¶)

### æ–‡ä»¶: `src/core/parser/MermaidParser.compat.test.ts`

```typescript
/**
 * Mermaid Flowchart å…¼å®¹æ€§æµ‹è¯•
 * åŸºäºå®˜æ–¹æ–‡æ¡£: https://mermaid.js.org/syntax/flowchart.html
 */
import { describe, it, expect } from 'vitest';
import { MermaidParser } from './MermaidParser';

const parser = new MermaidParser();

describe('Mermaid Flowchart å…¼å®¹æ€§æµ‹è¯•', () => {

  // ============================================
  // 1. åŸºç¡€è¯­æ³•
  // ============================================
  describe('1. åŸºç¡€è¯­æ³•', () => {

    it('1.1 æ”¯æŒ flowchart å’Œ graph å£°æ˜', () => {
      const m1 = parser.parse('flowchart LR\n  A');
      const m2 = parser.parse('graph LR\n  A');
      expect(m1.direction).toBe('LR');
      expect(m2.direction).toBe('LR');
    });

    it('1.2 æ”¯æŒæ‰€æœ‰æ–¹å‘ (TB, TD, BT, LR, RL)', () => {
      expect(parser.parse('flowchart TB\n  A').direction).toBe('TB');
      expect(parser.parse('flowchart TD\n  A').direction).toBe('TB'); // TD = TB
      expect(parser.parse('flowchart BT\n  A').direction).toBe('BT');
      expect(parser.parse('flowchart LR\n  A').direction).toBe('LR');
      expect(parser.parse('flowchart RL\n  A').direction).toBe('RL');
    });

    it('1.3 çº¯ ID èŠ‚ç‚¹', () => {
      const model = parser.parse('flowchart LR\n  id');
      expect(model.hasNode('id')).toBe(true);
      expect(model.getNode('id')?.text).toBe('id');
    });

    it('1.4 å¸¦æ–‡æœ¬çš„èŠ‚ç‚¹', () => {
      const model = parser.parse('flowchart LR\n  id1[This is the text in the box]');
      expect(model.getNode('id1')?.text).toBe('This is the text in the box');
    });
  });

  // ============================================
  // 2. èŠ‚ç‚¹å½¢çŠ¶ (ä¼ ç»Ÿè¯­æ³•)
  // ============================================
  describe('2. èŠ‚ç‚¹å½¢çŠ¶ (ä¼ ç»Ÿè¯­æ³•)', () => {

    it('2.1 çŸ©å½¢ [text]', () => {
      const model = parser.parse('flowchart LR\n  A[Rectangle]');
      expect(model.getNode('A')?.shape).toBe('rect');
    });

    it('2.2 åœ†è§’çŸ©å½¢ (text)', () => {
      const model = parser.parse('flowchart LR\n  A(Rounded)');
      expect(model.getNode('A')?.shape).toBe('rounded');
    });

    it('2.3 ä½“è‚²åœºå½¢ ([text])', () => {
      const model = parser.parse('flowchart LR\n  A([Stadium])');
      expect(model.getNode('A')?.shape).toBe('stadium');
    });

    it('2.4 å­ç¨‹åºæ¡† [[text]]', () => {
      const model = parser.parse('flowchart LR\n  A[[Subroutine]]');
      expect(model.getNode('A')?.shape).toBe('subroutine');
    });

    it('2.5 åœ†æŸ±ä½“ [(text)]', () => {
      const model = parser.parse('flowchart LR\n  A[(Database)]');
      expect(model.getNode('A')?.shape).toBe('cylinder');
    });

    it('2.6 åœ†å½¢ ((text))', () => {
      const model = parser.parse('flowchart LR\n  A((Circle))');
      expect(model.getNode('A')?.shape).toBe('circle');
    });

    it('2.7 åŒåœ†å½¢ (((text)))', () => {
      const model = parser.parse('flowchart LR\n  A(((Double Circle)))');
      expect(model.getNode('A')?.shape).toBe('doublecircle');
    });

    it('2.8 è±å½¢ {text}', () => {
      const model = parser.parse('flowchart LR\n  A{Diamond}');
      expect(model.getNode('A')?.shape).toBe('diamond');
    });

    it('2.9 å…­è¾¹å½¢ {{text}}', () => {
      const model = parser.parse('flowchart LR\n  A{{Hexagon}}');
      expect(model.getNode('A')?.shape).toBe('hexagon');
    });

    it('2.10 å¹³è¡Œå››è¾¹å½¢ [/text/]', () => {
      const model = parser.parse('flowchart LR\n  A[/Parallelogram/]');
      expect(model.getNode('A')?.shape).toBe('trapezoid');
    });

    it('2.11 åå‘å¹³è¡Œå››è¾¹å½¢ [\\text\\]', () => {
      const model = parser.parse('flowchart LR\n  A[\\Alt Parallelogram\\]');
      expect(model.getNode('A')?.shape).toBe('inv_trapezoid');
    });

    it('2.12 æ¢¯å½¢ [/text\\]', () => {
      const model = parser.parse('flowchart LR\n  A[/Trapezoid\\]');
      expect(model.getNode('A')?.shape).toBe('lean_right');
    });

    it('2.13 åå‘æ¢¯å½¢ [\\text/]', () => {
      const model = parser.parse('flowchart LR\n  A[\\Trapezoid Alt/]');
      expect(model.getNode('A')?.shape).toBe('lean_left');
    });

    it('2.14 æ——å¸œå½¢ >text]', () => {
      const model = parser.parse('flowchart LR\n  A>Asymmetric]');
      expect(model.getNode('A')?.shape).toBe('odd');
    });
  });

  // ============================================
  // 3. è¾¹ç±»å‹
  // ============================================
  describe('3. è¾¹ç±»å‹', () => {

    it('3.1 ç®­å¤´è¾¹ -->', () => {
      const model = parser.parse('flowchart LR\n  A --> B');
      expect(model.edges[0].arrowEnd).toBe('arrow');
      expect(model.edges[0].stroke).toBe('normal');
    });

    it('3.2 æ— ç®­å¤´è¾¹ ---', () => {
      const model = parser.parse('flowchart LR\n  A --- B');
      expect(model.edges[0].arrowEnd).toBe('none');
    });

    it('3.3 å¸¦æ–‡æœ¬çš„æ— ç®­å¤´è¾¹ -- text ---', () => {
      const model = parser.parse('flowchart LR\n  A-- This is the text! ---B');
      expect(model.edges[0].text).toBe('This is the text!');
      expect(model.edges[0].arrowEnd).toBe('none');
    });

    it('3.4 å¸¦æ–‡æœ¬çš„æ— ç®­å¤´è¾¹ ---|text|', () => {
      const model = parser.parse('flowchart LR\n  A---|This is the text|B');
      expect(model.edges[0].text).toBe('This is the text');
    });

    it('3.5 å¸¦ç®­å¤´å’Œæ–‡æœ¬ -->|text|', () => {
      const model = parser.parse('flowchart LR\n  A-->|text|B');
      expect(model.edges[0].text).toBe('text');
      expect(model.edges[0].arrowEnd).toBe('arrow');
    });

    it('3.6 å¸¦ç®­å¤´å’Œæ–‡æœ¬ -- text -->', () => {
      const model = parser.parse('flowchart LR\n  A-- text -->B');
      expect(model.edges[0].text).toBe('text');
      expect(model.edges[0].arrowEnd).toBe('arrow');
    });

    it('3.7 è™šçº¿è¾¹ -.->', () => {
      const model = parser.parse('flowchart LR\n  A-.->B');
      expect(model.edges[0].stroke).toBe('dotted');
      expect(model.edges[0].arrowEnd).toBe('arrow');
    });

    it('3.8 å¸¦æ–‡æœ¬è™šçº¿è¾¹ -. text .->', () => {
      const model = parser.parse('flowchart LR\n  A-. text .-> B');
      expect(model.edges[0].text).toBe('text');
      expect(model.edges[0].stroke).toBe('dotted');
    });

    it('3.9 ç²—çº¿è¾¹ ==>', () => {
      const model = parser.parse('flowchart LR\n  A ==> B');
      expect(model.edges[0].stroke).toBe('thick');
    });

    it('3.10 å¸¦æ–‡æœ¬ç²—çº¿è¾¹ == text ==>', () => {
      const model = parser.parse('flowchart LR\n  A == text ==> B');
      expect(model.edges[0].text).toBe('text');
      expect(model.edges[0].stroke).toBe('thick');
    });

    it('3.11 åœ†å½¢ç®­å¤´ --o', () => {
      const model = parser.parse('flowchart LR\n  A --o B');
      expect(model.edges[0].arrowEnd).toBe('circle');
    });

    it('3.12 åŒå‘åœ†å½¢ç®­å¤´ o--o', () => {
      const model = parser.parse('flowchart LR\n  A o--o B');
      expect(model.edges[0].arrowStart).toBe('circle');
      expect(model.edges[0].arrowEnd).toBe('circle');
    });

    it('3.13 å‰å½¢ç®­å¤´ --x', () => {
      const model = parser.parse('flowchart LR\n  A --x B');
      expect(model.edges[0].arrowEnd).toBe('cross');
    });

    it('3.14 åŒå‘å‰å½¢ç®­å¤´ x--x', () => {
      const model = parser.parse('flowchart LR\n  A x--x B');
      expect(model.edges[0].arrowStart).toBe('cross');
      expect(model.edges[0].arrowEnd).toBe('cross');
    });

    it('3.15 åŒå‘ç®­å¤´ <-->', () => {
      const model = parser.parse('flowchart LR\n  A <--> B');
      expect(model.edges[0].arrowStart).toBe('arrow');
      expect(model.edges[0].arrowEnd).toBe('arrow');
    });
  });

  // ============================================
  // 4. é“¾å¼è¿æ¥
  // ============================================
  describe('4. é“¾å¼è¿æ¥', () => {

    it('4.1 èŠ‚ç‚¹é“¾ A --> B --> C', () => {
      const model = parser.parse('flowchart LR\n  A --> B --> C');
      expect(model.edgeCount).toBe(2);
      expect(model.edges.find(e => e.source === 'A' && e.target === 'B')).toBeDefined();
      expect(model.edges.find(e => e.source === 'B' && e.target === 'C')).toBeDefined();
    });

    it('4.2 å¸¦æ–‡æœ¬çš„èŠ‚ç‚¹é“¾', () => {
      const model = parser.parse('flowchart LR\n  A -- text --> B -- text2 --> C');
      expect(model.edges[0].text).toBe('text');
      expect(model.edges[1].text).toBe('text2');
    });
  });

  // ============================================
  // 5. å¾…å®ç°åŠŸèƒ½ (é¢„ç•™æµ‹è¯•)
  // ============================================
  describe('5. å¾…å®ç°: ä¸å¯è§è¾¹ ~~~', () => {

    it.skip('5.1 ä¸å¯è§è¾¹åº”è§£æä¸º invisible stroke', () => {
      const model = parser.parse('flowchart LR\n  A ~~~ B');
      expect(model.edges[0].stroke).toBe('invisible');
    });
  });

  describe('5. å¾…å®ç°: å¤šèŠ‚ç‚¹é“¾æ¥ &', () => {

    it.skip('5.2 A & B --> C åº”å±•å¼€ä¸º 2 æ¡è¾¹', () => {
      const model = parser.parse('flowchart LR\n  A & B --> C');
      expect(model.edgeCount).toBe(2);
    });

    it.skip('5.3 A & B --> C & D åº”å±•å¼€ä¸º 4 æ¡è¾¹', () => {
      const model = parser.parse('flowchart TB\n  A & B--> C & D');
      expect(model.edgeCount).toBe(4);
    });
  });

  describe('5. å¾…å®ç°: è¾¹é•¿åº¦æ§åˆ¶', () => {

    it.skip('5.4 å¤šç ´æŠ˜å·åº”å¢åŠ è¾¹é•¿åº¦', () => {
      const model = parser.parse('flowchart TD\n  A ---> B\n  A ----> C');
      expect(model.edges[0].length).toBe(2);
      expect(model.edges[1].length).toBe(3);
    });
  });

  describe('5. å¾…å®ç°: æ–°å½¢çŠ¶è¯­æ³• @{}', () => {

    it.skip('5.5 @{ shape: rect } åº”è§£æä¸ºçŸ©å½¢', () => {
      const model = parser.parse('flowchart TD\n  A@{ shape: rect, label: "Process" }');
      expect(model.getNode('A')?.shape).toBe('rect');
      expect(model.getNode('A')?.text).toBe('Process');
    });

    it.skip('5.6 @{ shape: doc } åº”è§£æä¸ºæ–‡æ¡£å½¢çŠ¶', () => {
      const model = parser.parse('flowchart TD\n  A@{ shape: doc, label: "Document" }');
      expect(model.getNode('A')?.shape).toBe('doc');
    });
  });

  describe('5. å¾…å®ç°: è¾¹ ID å’ŒåŠ¨ç”»', () => {

    it.skip('5.7 è¾¹ ID è¯­æ³• e1@-->', () => {
      const model = parser.parse('flowchart LR\n  A e1@--> B');
      expect(model.edges[0].id).toBe('e1');
      expect(model.edges[0].isUserDefinedId).toBe(true);
    });

    it.skip('5.8 è¾¹åŠ¨ç”»é…ç½®', () => {
      const model = parser.parse(`flowchart LR
        A e1@--> B
        e1@{ animate: true }`);
      expect(model.edges[0].animate).toBe(true);
    });
  });

  // ============================================
  // 6. å­å›¾
  // ============================================
  describe('6. å­å›¾', () => {

    it('6.1 åŸºç¡€å­å›¾', () => {
      const model = parser.parse(`flowchart TB
        subgraph one
          a1-->a2
        end`);
      expect(model.subGraphs.length).toBe(1);
      expect(model.subGraphs[0].id).toBe('one');
    });

    it('6.2 å¸¦æ ‡é¢˜çš„å­å›¾', () => {
      const model = parser.parse(`flowchart TB
        subgraph ide1 [One Title]
          a1-->a2
        end`);
      expect(model.subGraphs[0].id).toBe('ide1');
      expect(model.subGraphs[0].title).toBe('One Title');
    });

    it.skip('6.3 å­å›¾å†…æ–¹å‘ (å¾…å®ç°)', () => {
      const model = parser.parse(`flowchart LR
        subgraph TOP
          direction TB
          A --> B
        end`);
      expect(model.subGraphs[0].direction).toBe('TB');
    });
  });

  // ============================================
  // 7. æ ·å¼
  // ============================================
  describe('7. æ ·å¼', () => {

    it('7.1 classDef', () => {
      const model = parser.parse(`flowchart LR
        A:::someclass --> B
        classDef someclass fill:#f96`);
      const classDef = model.getClassDef('someclass');
      expect(classDef).toBeDefined();
      expect(classDef?.styles).toContain('fill:#f96');
    });

    it('7.2 style è¯­å¥', () => {
      const model = parser.parse(`flowchart LR
        A
        style A fill:#f9f,stroke:#333,stroke-width:4px`);
      expect(model.getNode('A')?.style?.fill).toBe('#f9f');
    });

    it('7.3 class åˆ†é…', () => {
      const model = parser.parse(`flowchart LR
        A
        B
        class A,B someClass`);
      expect(model.getNode('A')?.cssClasses).toContain('someClass');
      expect(model.getNode('B')?.cssClasses).toContain('someClass');
    });

    it.skip('7.4 linkStyle (å¾…å®ç°)', () => {
      const model = parser.parse(`flowchart LR
        A --> B
        linkStyle 0 stroke:#ff3,stroke-width:4px`);
      expect(model.edges[0].style).toBeDefined();
    });
  });

  // ============================================
  // 8. ç‰¹æ®Šæƒ…å†µ
  // ============================================
  describe('8. ç‰¹æ®Šæƒ…å†µ', () => {

    it('8.1 æ³¨é‡Šåº”è¢«å¿½ç•¥', () => {
      const model = parser.parse(`flowchart LR
        %% This is a comment
        A --> B`);
      expect(model.nodeCount).toBe(2);
    });

    it('8.2 è¡Œå†…æ³¨é‡Š', () => {
      const model = parser.parse(`flowchart LR
        A --> B %% inline comment`);
      expect(model.edgeCount).toBe(1);
    });

    it('8.3 click è¯­å¥', () => {
      const model = parser.parse(`flowchart LR
        A[Node]
        click A "https://example.com" "_blank"`);
      expect(model.getNode('A')?.link).toBe('https://example.com');
      expect(model.getNode('A')?.linkTarget).toBe('_blank');
    });

    it('8.4 å¸¦å¼•å·çš„æ–‡æœ¬ (ç‰¹æ®Šå­—ç¬¦)', () => {
      const model = parser.parse(`flowchart LR
        A["Text with (parentheses)"]`);
      expect(model.getNode('A')?.text).toBe('Text with (parentheses)');
      expect(model.getNode('A')?.shape).toBe('rect');
    });

    it.skip('8.5 Unicode æ–‡æœ¬ (å¾…å®ç°)', () => {
      const model = parser.parse(`flowchart LR
        A["This â¤ Unicode"]`);
      expect(model.getNode('A')?.text).toBe('This â¤ Unicode');
    });

    it.skip('8.6 å®ä½“ç¼–ç  (å¾…å®ç°)', () => {
      const model = parser.parse(`flowchart LR
        A["A double quote:#quot;"]`);
      expect(model.getNode('A')?.text).toContain('"');
    });
  });
});
```

---

## ğŸ“Š æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡

| æ¨¡å— | å½“å‰è¦†ç›– | ç›®æ ‡è¦†ç›– |
|------|----------|----------|
| MermaidParser | ~70% | 90%+ |
| MermaidSerializer | ~60% | 85%+ |
| FlowchartModel | ~80% | 90%+ |

---

## ğŸš€ è¿è¡Œæµ‹è¯•

```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
pnpm test

# è¿è¡Œç‰¹å®šæµ‹è¯•æ–‡ä»¶
pnpm test src/core/parser/MermaidParser.compat.test.ts

# è¿è¡Œå¹¶æŸ¥çœ‹è¦†ç›–ç‡
pnpm test --coverage

# ç›‘å¬æ¨¡å¼
pnpm test --watch
```

---

## ğŸ“ æµ‹è¯•å‘½åè§„èŒƒ

- `x.y æè¿°` - ç¼–å· + æè¿°
- `it.skip()` - å¾…å®ç°åŠŸèƒ½
- æŒ‰å®˜æ–¹æ–‡æ¡£ç« èŠ‚ç»„ç»‡

---

## ğŸ”— å‚è€ƒ

- [Mermaid Flowchart å®˜æ–¹æ–‡æ¡£](https://mermaid.js.org/syntax/flowchart.html)
- [Mermaid è¯­æ³•å‚è€ƒ](https://mermaid.js.org/intro/syntax-reference.html)

